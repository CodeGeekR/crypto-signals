---
// Interface para las props del componente
export interface Props {
  targetDate?: string;
  className?: string;
}

const {
  targetDate = "30", // DÃ­as por defecto
  className = "",
} = Astro.props;
---

<div class={`countdown-container ${className}`}>
  <!-- TÃ­tulo optimizado - Un solo elemento -->
  <div class="countdown-title mb-4 text-center">
    <span class="text-xs sm:text-sm text-orange-300 font-medium"> ðŸš€ Lista VIP cierra en: </span>
  </div>

  <!-- Timer simplificado - Eliminados wrappers innecesarios -->
  <div class="domino-timer flex justify-center items-center gap-2 sm:gap-3 md:gap-4 max-w-lg mx-auto">
    <!-- DÃ­as - Estructura simplificada -->
    <div class="time-unit">
      <div class="domino-card" id="days-card" data-value="--">--</div>
      <span class="time-label">dÃ­as</span>
    </div>

    <!-- Horas -->
    <div class="time-unit">
      <div class="domino-card" id="hours-card" data-value="--">--</div>
      <span class="time-label">horas</span>
    </div>

    <!-- Minutos -->
    <div class="time-unit">
      <div class="domino-card" id="minutes-card" data-value="--">--</div>
      <span class="time-label">min</span>
    </div>

    <!-- Segundos -->
    <div class="time-unit">
      <div class="domino-card" id="seconds-card" data-value="--">--</div>
      <span class="time-label">seg</span>
    </div>
  </div>

  <!-- Estado de expiraciÃ³n optimizado -->
  <div class="countdown-expired hidden text-center mt-4 text-red-400 font-bold text-sm sm:text-base">
    ðŸ”´ Oferta Expirada
  </div>
</div>

<style>
  /* Estilos optimizados - ReducciÃ³n masiva de DOM */
  .countdown-container {
    @apply w-full;
  }

  .time-unit {
    @apply flex flex-col items-center space-y-2;
  }

  .domino-card {
    @apply w-14 h-16 sm:w-16 sm:h-20 md:w-20 md:h-24 rounded-lg flex items-center justify-center;
    @apply text-base sm:text-lg md:text-xl font-bold font-mono text-white;
    background: linear-gradient(145deg, #1e293b, #475569);
    box-shadow:
      0 8px 16px rgba(0, 0, 0, 0.4),
      inset 0 2px 4px rgba(255, 255, 255, 0.1);
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
    transition: all 0.5s ease;
    border: 1px solid rgba(148, 163, 184, 0.2);
  }

  .time-label {
    @apply text-xs text-gray-400 font-medium;
  }

  /* Responsive optimizado */
  @media (max-width: 480px) {
    .domino-card {
      @apply w-12 h-14 text-sm;
    }
  }

  /* Hover efecto simple */
  .domino-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 12px 24px rgba(0, 0, 0, 0.5);
  }

  /* Animaciones de entrada simplificadas */
  .time-unit {
    opacity: 0;
    animation: slideUp 0.6s ease-out forwards;
  }

  .time-unit:nth-child(1) {
    animation-delay: 0.2s;
  }
  .time-unit:nth-child(2) {
    animation-delay: 0.3s;
  }
  .time-unit:nth-child(3) {
    animation-delay: 0.4s;
  }
  .time-unit:nth-child(4) {
    animation-delay: 0.5s;
  }

  @keyframes slideUp {
    to {
      opacity: 1;
      transform: translateY(0);
    }
    from {
      opacity: 0;
      transform: translateY(20px);
    }
  }
</style>

<script>
  // Lightweight countdown timer - Optimizado para DOM mÃ­nimo
  class SimpleCountdownTimer {
    private targetDate: Date;
    private intervalId: number | null = null;
    private readonly STORAGE_KEY = "cryptosenales-countdown-target";

    constructor(daysFromNow: number = 30) {
      this.targetDate = this.getOrCreateTargetDate(daysFromNow);
      this.updateTime();
      this.startTimer();
    }

    private getOrCreateTargetDate(daysFromNow: number): Date {
      try {
        // Intentar obtener fecha existente del localStorage
        const storedTarget = localStorage.getItem(this.STORAGE_KEY);

        if (storedTarget) {
          const savedDate = new Date(storedTarget);
          // Verificar que la fecha sea vÃ¡lida y estÃ© en el futuro
          if (savedDate.getTime() > Date.now()) {
            return savedDate;
          }
        }
      } catch (error) {
        // Si localStorage no estÃ¡ disponible, continuar con fecha nueva
        console.warn("localStorage no disponible, usando fecha temporal");
      }

      // ðŸŽ¯ Fecha objetivo FIJA y realista para el lanzamiento
      // Establecer una fecha especÃ­fica en el futuro (ej: 15 de febrero de 2025)
      const launchDate = new Date("2025-07-15T23:59:59Z"); // Fecha UTC fija

      // Si la fecha ya pasÃ³, usar 30 dÃ­as desde ahora como fallback
      const newTarget =
        launchDate.getTime() > Date.now() ? launchDate : new Date(Date.now() + daysFromNow * 24 * 60 * 60 * 1000);

      // Guardar en localStorage para persistencia
      try {
        localStorage.setItem(this.STORAGE_KEY, newTarget.toISOString());
      } catch (error) {
        // Si localStorage falla, continuar sin persistencia
        console.warn("No se pudo guardar fecha objetivo");
      }

      return newTarget;
    }

    private updateTime(): void {
      const now = new Date().getTime();
      const distance = this.targetDate.getTime() - now;

      if (distance < 0) {
        this.handleExpiration();
        return;
      }

      const days = Math.floor(distance / (1000 * 60 * 60 * 24));
      const hours = Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
      const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
      const seconds = Math.floor((distance % (1000 * 60)) / 1000);

      // Actualizar directamente sin animaciones complejas
      this.updateElement("days", days);
      this.updateElement("hours", hours);
      this.updateElement("minutes", minutes);
      this.updateElement("seconds", seconds);
    }

    private updateElement(unit: string, value: number): void {
      const element = document.getElementById(`${unit}-card`);
      if (element) {
        element.textContent = value.toString().padStart(2, "0");
      }
    }

    private handleExpiration(): void {
      this.stopTimer();
      const expiredElement = document.querySelector(".countdown-expired") as HTMLElement;
      const timerElement = document.querySelector(".domino-timer") as HTMLElement;

      if (expiredElement && timerElement) {
        timerElement.style.opacity = "0";
        expiredElement.classList.remove("hidden");

        // ðŸ—‘ï¸ Limpiar localStorage cuando expire para evitar fechas pasadas
        try {
          localStorage.removeItem(this.STORAGE_KEY);
        } catch (error) {
          console.warn("No se pudo limpiar localStorage");
        }
      }
    }

    private startTimer(): void {
      this.intervalId = window.setInterval(() => {
        this.updateTime();
      }, 1000);
    }

    private stopTimer(): void {
      if (this.intervalId) {
        clearInterval(this.intervalId);
        this.intervalId = null;
      }
    }

    // ðŸ”„ MÃ©todo pÃºblico para reinicializar el contador (Ãºtil para testing)
    public resetCountdown(): void {
      try {
        localStorage.removeItem(this.STORAGE_KEY);
        this.stopTimer();
        this.targetDate = this.getOrCreateTargetDate(30);
        this.updateTime();
        this.startTimer();
      } catch (error) {
        console.warn("No se pudo reinicializar el contador");
      }
    }
  }

  // Inicializar simplificado
  document.addEventListener("DOMContentLoaded", () => {
    const timer = new SimpleCountdownTimer(30);

    // ðŸ› ï¸ Exposer mÃ©todo global para desarrollo/testing
    (window as any).resetCountdown = () => timer.resetCountdown();
  });
</script>
